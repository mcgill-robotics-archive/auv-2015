#! /usr/bin/env python2.7

import cv2
import math
import numpy as np
from numpy import linalg as LA
from cv_backbone import CvBackbone, filters

'''
Author: Wei-Di Chang

The approach used here is to use findContours, and then filter out bad
candidates based on size and shape.
'''


def suppressBadShapes(contours):
    # Here we try to find something that looks like a lane, including the legs
    lane = np.array([[[5, 0]], [[5, 14]], [[0, 14]], [[0, 16]],
                    [[5, 16]], [[5, 70]], [[0, 70]], [[0, 72]],
                    [[5, 72]], [[5, 86]], [[15, 86]], [[15, 72]],
                    [[20, 72]], [[20, 70]], [[15, 70]], [[15, 16]],
                    [[20, 16]], [[20, 14]], [[15, 14]], [[15, 0]]])
    return filters.suppressBadShapes(contours, lane, 1.25)


def dist(p1, p2):
    # Distance between two points
    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)


def sideLengths(rect):
    # Returns the lengths of the sides of the rectangle
    return map(lambda i: dist(rect[i-1], rect[i]), range(4))


def filterIntensities(contours, img, flag, intensity_change):
    # Tests for rectangles where the area just outside the border
    # is lighter than just inside. This is useful to suppress the
    # outside of the bins.
    if flag == 0:
        return contours

    valid = []
    border = 0.1
    for c in contours:
        # Scale contour up and down
        outer_border = np.int32((1+border)*c - border*np.average(c, axis=0))
        inner_border = np.int32((1-border)*c + border*np.average(c, axis=0))
        # Calculate average inner and outer border intensities
        outer_avg = filters.contourIntensityAverage(img, outer_border, c)
        inner_avg = filters.contourIntensityAverage(img, c, inner_border)
        if flag == 1:
            if outer_avg > inner_avg + intensity_change:
                valid.append(c)
        elif flag == -1:
            if inner_avg > outer_avg + intensity_change:
                valid.append(c)
    return valid


def angle_cos(p0, p1, p2):
    d1, d2 = (p0-p1).astype('float'), (p2-p1).astype('float')
    return abs(np.dot(d1, d2) / np.sqrt(np.dot(d1, d1)*np.dot(d2, d2)))


def filterEccentricity(contours, eccentricity_thresh):
    # Filters out contours based on ratio of major-axis/minor-axis - not
    # exactly "eccentricity" by definition
    valid = []
    for cnt in contours:
        moment = cv2.moments(cnt)
        if(moment['m00'] != 0):
            covariance = np.matrix([[moment['m20']/moment['m00'],
                                   moment['m11']/moment['m00']],
                                   [moment['m11']/moment['m00'],
                                   moment['m02']/moment['m00']]])
        else:
            continue
        eigenValues = LA.eigvals(covariance)
        eigenValues.sort()
        eccentricity = np.sqrt(eigenValues[1]/eigenValues[0])
        # print eccentricity
        if(eccentricity < eccentricity_thresh):
            valid.append(cnt)
    return valid


def validate(contours, img):
    # Minimum perimeter of target
    min_length = 20*4
    # Minimum area of target
    min_area = 35  # Increasing to 40 suppresses target
    validContours = filters.filterSize(contours, min_length, min_area)  # Use
    # Tolerance for polygon fitting. Increasing means things get fit
    # with fewer vertices.
    eccentricity_threshold = 17
    validContours = filterEccentricity(contours, eccentricity_threshold)  # Use
    validContours = suppressBadShapes(validContours)

    # Flag for how the intensity changes from the inside of the border to the
    # outside of the border. 1 means that the outside is more intense than the
    # inside. 0 means there isn't a difference. -1 means the inside is more
    # intense than the outside.
    intensity_change_flag = -1
    # Minimum average increase in intensity
    # For Lanes, inside is more intense in the Red channel by about
    # 115 (= 175 - 60) Using greyscale for now, inside more intense by 70
    intensity_change = 20
    validContours = filterIntensities(validContours, img,
                                      intensity_change_flag, intensity_change)
    validContours = filters.suppressConcentric(validContours)  # use

    return validContours


def findByContours(orig):
    img = orig.copy()
    gray = cb.filters.grayScale(img)
    gray = cb.filters.medianBlur(gray)
    img = cv2.Canny(gray, 0, 100, apertureSize=5)
    contours, _ = cv2.findContours(img, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
    contours = validate(contours, cv2.split(orig)[2])
    cv2.drawContours(orig, contours, -1, (0, 0, 255), 1)
    cb.publishImage(orig)

if __name__ == '__main__':
    global cb
    cb = CvBackbone.CvBackbone('lane_detection')
    cb.addImageCallback(findByContours)
    cb.start()
